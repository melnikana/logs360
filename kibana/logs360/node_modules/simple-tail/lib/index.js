/**
 * simple-tail
 * Tail last n lines from a given file.
 * Jesús Ángel González Novez
 * Forked and inspired from https://github.com/alexbbt/read-last-lines
 * Thanks to @alexbbt 
 */
import 'babel-polyfill';
import fs from 'mz/fs';

/**
 * Read in the last `n` lines of a file
 * @param  {string}   inputFilePath - file (direct or relative path to file.)
 * @param  {int}      maxLineCount  - max number of lines to read in.
 *
 * @return {promise}  A promise resolved with the lines or rejected with an error.
 */
const tail = async (inputFilePath, maxLineCount) => {
    const self = {
        stat: null,
        file: null,
    };
    try {
        const NEW_LINE_CHARACTERS = ["\n", "\r"];
        const encoding = "utf8";

        const readPreviousChar = function (stat, file, currentCharacterCount) {
            return fs.read(file, Buffer.alloc(1), 0, 1, stat.size - 1 - currentCharacterCount)
                .then((bytesReadAndBuffer) => {
                    return String.fromCharCode(bytesReadAndBuffer[1][0]);
                });
        };

        const exists = await fs.exists(inputFilePath)

        if (!exists) {
            const noExistsError = new Error("File does not exist");
            noExistsError.code = 'ENOENT';
            throw noExistsError;
        }

        const promises = [];

        // Load file Stats.
        promises.push(fs.stat(inputFilePath).then(stat => self.stat = stat));

        // Open file for reading.
        promises.push(fs.open(inputFilePath, "r").then(file => self.file = file));

        return Promise.all(promises)
            .then(() => {

                let chars = 0;
                let lineCount = 0;
                let lines = "";

                const doWhileLoop = function () {
                    if (lines.length > self.stat.size) {
                        lines = lines.substring(lines.length - self.stat.size);
                    }

                    if (lines.length >= self.stat.size || lineCount >= maxLineCount) {
                        if (NEW_LINE_CHARACTERS.includes(lines.substring(0, 1))) {
                            lines = lines.substring(1);
                        }
                        fs.close(self.file);

                        return lines.split('\n').reverse() || [];
                    }

                    return readPreviousChar(self.stat, self.file, chars)
                        .then((nextCharacter) => {
                            lines = nextCharacter + lines;
                            if (NEW_LINE_CHARACTERS.includes(nextCharacter) && lines.length > 1) {
                                lineCount++;
                            }
                            chars++;
                        })
                        .then(doWhileLoop);
                };
                return doWhileLoop();
            })
            .catch(error => { throw new Error(error) });
    } catch (error) {
        if (self.file !== null) {
            fs.close(self.file);
        }
        return Promise.reject(error);
    }
};

export default tail;